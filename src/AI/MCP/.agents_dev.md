# Guía de Implementación: Parseador de Tools MCP

## Contexto del Descubrimiento

Tras analizar el código fuente del `@modelcontextprotocol/inspector` oficial de Anthropic, se ha identificado la arquitectura exacta para extraer tools de servidores MCP con sus esquemas completos.

## Arquitectura Clave Descubierta

### 1. SDK Oficial de MCP
```typescript
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import type { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
```

### 2. Métodos Principales para Obtener Metadata Completa
```typescript
// Tools - Lista todas las herramientas con esquemas
export async function listTools(client: Client): Promise<McpResponse> {
  try {
    const response = await client.listTools();
    return response; // Contiene array de Tool con inputSchema completo
  } catch (error) {
    throw new Error(`Failed to list tools: ${error.message}`);
  }
}

// Resources - Lista recursos disponibles con URIs y esquemas
export async function listResources(client: Client): Promise<McpResponse> {
  try {
    const response = await client.listResources();
    return response; // Contiene array de Resource con uri, name, description
  } catch (error) {
    throw new Error(`Failed to list resources: ${error.message}`);
  }
}

// Resource Templates - Plantillas de recursos dinámicos
export async function listResourceTemplates(client: Client): Promise<McpResponse> {
  try {
    const response = await client.listResourceTemplates();
    return response; // Contiene templates con uriTemplate y argumentos
  } catch (error) {
    throw new Error(`Failed to list resource templates: ${error.message}`);
  }
}

// Prompts - Lista prompts disponibles con sus esquemas de argumentos
export async function listPrompts(client: Client): Promise<McpResponse> {
  try {
    const response = await client.listPrompts();
    return response; // Contiene array de Prompt con argumentos y descripción
  } catch (error) {
    throw new Error(`Failed to list prompts: ${error.message}`);
  }
}

// Leer contenido específico de un resource
export async function readResource(client: Client, uri: string): Promise<McpResponse> {
  try {
    const response = await client.readResource({ uri });
    return response; // Contiene contenido del resource
  } catch (error) {
    throw new Error(`Failed to read resource ${uri}: ${error.message}`);
  }
}

// Obtener un prompt específico con argumentos
export async function getPrompt(
  client: Client, 
  name: string, 
  args?: Record<string, any>
): Promise<McpResponse> {
  try {
    const response = await client.getPrompt({
      name,
      arguments: args || {}
    });
    return response; // Contiene el prompt expandido con argumentos
  } catch (error) {
    throw new Error(`Failed to get prompt: ${error.message}`);
  }
}
```

### 3. Estructura Completa de Metadata MCP
```typescript
import { Tool, Prompt, Resource } from "@modelcontextprotocol/sdk/types.js";

// Tool con esquema de entrada
interface Tool {
  name: string;
  description?: string;
  inputSchema: {
    type: "object";
    properties: Record<string, JsonSchemaType>;
    required?: string[];
  };
}

// Resource con URI y metadatos
interface Resource {
  uri: string;
  name: string;
  description?: string;
  mimeType?: string;
}

// Resource Template con URI dinámica
interface ResourceTemplate {
  uriTemplate: string;
  name: string;
  description?: string;
  mimeType?: string;
}

// Prompt con argumentos
interface Prompt {
  name: string;
  description?: string;
  arguments?: Array<{
    name: string;
    description?: string;
    required?: boolean;
  }>;
}

interface JsonSchemaType {
  type: "string" | "number" | "integer" | "boolean" | "array" | "object";
  description?: string;
  properties?: Record<string, JsonSchemaType>;
  items?: JsonSchemaType;
  enum?: any[];
}
```

## Implementación Requerida

### 1. Estructura del Proyecto
```
mcp-tools-parser/
├── package.json
├── src/
│   ├── index.ts
│   ├── mcpClient.ts
│   ├── schemaParser.ts
│   ├── transformer.ts
│   └── types/
│       ├── tools.ts
│       ├── resources.ts
│       └── prompts.ts
└── output/
    └── schemas.json
```

### 2. Dependencias Necesarias
```json
{
  "dependencies": {
    "@modelcontextprotocol/sdk": "latest",
    "commander": "^11.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  }
}
```

### 3. Cliente MCP Base (`mcpClient.ts`)
```typescript
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { 
  StdioClientTransport,
  SSEClientTransport 
} from "@modelcontextprotocol/sdk/client/index.js";

export interface MCPServerMetadata {
  tools: Tool[];
  resources: Resource[];
  resourceTemplates: ResourceTemplate[];
  prompts: Prompt[];
  serverInfo?: any;
}

export class MCPToolsExtractor {
  private client: Client;
  
  constructor() {
    this.client = new Client({
      name: "mcp-tools-parser",
      version: "1.0.0"
    });
  }

  async connectToServer(serverUrl: string, transport: 'stdio' | 'sse' | 'streamable-http') {
    // Implementar conexión según el inspector
    // Código basado en inspector/cli/src/transport.ts
  }

  async extractTools(): Promise<Tool[]> {
    // Replicar exactamente listTools() del inspector
    const response = await this.client.listTools();
    return response.tools;
  }

  async extractResources(): Promise<Resource[]> {
    const response = await this.client.listResources();
    return response.resources;
  }

  async extractResourceTemplates(): Promise<ResourceTemplate[]> {
    const response = await this.client.listResourceTemplates();
    return response.resourceTemplates;
  }

  async extractPrompts(): Promise<Prompt[]> {
    const response = await this.client.listPrompts();
    return response.prompts;
  }

  async extractCompleteMetadata(): Promise<MCPServerMetadata> {
    // Obtener todo el metadata del servidor de una vez
    const [tools, resources, resourceTemplates, prompts] = await Promise.all([
      this.client.listTools(),
      this.client.listResources(),
      this.client.listResourceTemplates(),
      this.client.listPrompts()
    ]);
    
    return { 
      tools: tools.tools, 
      resources: resources.resources,
      resourceTemplates: resourceTemplates.resourceTemplates,
      prompts: prompts.prompts
    };
  }

  async readSpecificResource(uri: string): Promise<any> {
    const response = await this.client.readResource({ uri });
    return response;
  }

  async getSpecificPrompt(name: string, args?: Record<string, any>): Promise<any> {
    const response = await this.client.getPrompt({
      name,
      arguments: args || {}
    });
    return response;
  }
}
```

### 4. Parser de Esquemas (`schemaParser.ts`)
```typescript
import { Tool, Resource, Prompt } from "@modelcontextprotocol/sdk/types.js";

export interface ParsedTool {
  name: string;
  description: string;
  parameters: Parameter[];
  returnType?: string;
  category?: string;
}

export interface ParsedResource {
  uri: string;
  name: string;
  description?: string;
  mimeType?: string;
  category?: string;
  isTemplate?: boolean;
  templateArgs?: string[];
}

export interface ParsedPrompt {
  name: string;
  description?: string;
  arguments: PromptArgument[];
  category?: string;
}

export interface Parameter {
  name: string;
  type: string;
  description?: string;
  required: boolean;
  schema: any; // JSON Schema completo
}

export interface PromptArgument {
  name: string;
  description?: string;
  required: boolean;
}

export class SchemaParser {
  parseTools(tools: Tool[]): ParsedTool[] {
    return tools.map(tool => this.parseTool(tool));
  }

  parseResources(resources: Resource[]): ParsedResource[] {
    return resources.map(resource => this.parseResource(resource));
  }

  parsePrompts(prompts: Prompt[]): ParsedPrompt[] {
    return prompts.map(prompt => this.parsePrompt(prompt));
  }

  private parseTool(tool: Tool): ParsedTool {
    // Convertir inputSchema a formato estructurado
    const parameters = this.extractParameters(tool.inputSchema);
    
    return {
      name: tool.name,
      description: tool.description || '',
      parameters,
      category: this.inferToolCategory(tool.name),
    };
  }

  private parseResource(resource: Resource): ParsedResource {
    return {
      uri: resource.uri,
      name: resource.name,
      description: resource.description,
      mimeType: resource.mimeType,
      category: this.inferResourceCategory(resource.name),
      isTemplate: false
    };
  }

  private parsePrompt(prompt: Prompt): ParsedPrompt {
    const arguments = (prompt.arguments || []).map(arg => ({
      name: arg.name,
      description: arg.description,
      required: arg.required || false
    }));

    return {
      name: prompt.name,
      description: prompt.description,
      arguments,
      category: this.inferPromptCategory(prompt.name)
    };
  }

  private extractParameters(inputSchema: any): Parameter[] {
    // Procesar properties del JSON Schema
    // Extraer tipos, descripciones, required fields
    const properties = inputSchema.properties || {};
    const required = inputSchema.required || [];
    
    return Object.entries(properties).map(([name, schema]: [string, any]) => ({
      name,
      type: schema.type,
      description: schema.description,
      required: required.includes(name),
      schema
    }));
  }

  private inferToolCategory(name: string): string {
    // Inferir categoría basada en nombre
    if (name.includes('file') || name.includes('read') || name.includes('write')) {
      return 'file-operations';
    }
    if (name.includes('git') || name.includes('commit')) {
      return 'version-control';
    }
    return 'general';
  }

  private inferResourceCategory(name: string): string {
    if (name.includes('config') || name.includes('setting')) {
      return 'configuration';
    }
    if (name.includes('data') || name.includes('json')) {
      return 'data';
    }
    return 'general';
  }

  private inferPromptCategory(name: string): string {
    if (name.includes('code') || name.includes('generate')) {
      return 'code-generation';
    }
    if (name.includes('explain') || name.includes('analyze')) {
      return 'analysis';
    }
    return 'general';
  }
}
```

### 5. Transformador Configurable (`transformer.ts`)
```typescript
export interface TransformConfig {
  outputFormat: 'custom' | 'openapi' | 'json-schema';
  includeMetadata: boolean;
  groupByCategory: boolean;
  includeResources: boolean;
  includePrompts: boolean;
  customSchema?: any;
}

export interface CompleteServerSchema {
  serverInfo: {
    name: string;
    extractedAt: string;
    toolsCount: number;
    resourcesCount: number;
    promptsCount: number;
  };
  tools: ParsedTool[];
  resources: ParsedResource[];
  prompts: ParsedPrompt[];
  relationships: {
    toolsUsingResources: Array<{
      toolName: string;
      resourceUris: string[];
    }>;
    toolsUsingPrompts: Array<{
      toolName: string;
      promptNames: string[];
    }>;
  };
}

export class ToolsTransformer {
  transform(
    metadata: MCPServerMetadata, 
    config: TransformConfig
  ): CompleteServerSchema | any {
    const parser = new SchemaParser();
    
    const parsedTools = parser.parseTools(metadata.tools);
    const parsedResources = config.includeResources ? parser.parseResources(metadata.resources) : [];
    const parsedPrompts = config.includePrompts ? parser.parsePrompts(metadata.prompts) : [];
    
    const completeSchema: CompleteServerSchema = {
      serverInfo: {
        name: "MCP Server",
        extractedAt: new Date().toISOString(),
        toolsCount: parsedTools.length,
        resourcesCount: parsedResources.length,
        promptsCount: parsedPrompts.length
      },
      tools: parsedTools,
      resources: parsedResources,
      prompts: parsedPrompts,
      relationships: this.analyzeRelationships(parsedTools, parsedResources, parsedPrompts)
    };

    switch (config.outputFormat) {
      case 'custom':
        return this.toCustomFormat(completeSchema, config.customSchema);
      case 'openapi':
        return this.toOpenAPIFormat(completeSchema);
      case 'json-schema':
        return this.toJSONSchemaFormat(completeSchema);
      default:
        return completeSchema;
    }
  }

  private analyzeRelationships(
    tools: ParsedTool[], 
    resources: ParsedResource[], 
    prompts: ParsedPrompt[]
  ) {
    // Analizar qué tools pueden usar qué resources/prompts
    const toolsUsingResources: Array<{toolName: string, resourceUris: string[]}> = [];
    const toolsUsingPrompts: Array<{toolName: string, promptNames: string[]}> = [];
    
    tools.forEach(tool => {
      // Buscar parámetros que puedan referenciar resources
      const resourceParams = tool.parameters.filter(p => 
        p.name.includes('uri') || 
        p.name.includes('resource') ||
        p.description?.includes('resource')
      );
      
      if (resourceParams.length > 0) {
        toolsUsingResources.push({
          toolName: tool.name,
          resourceUris: resources.map(r => r.uri)
        });
      }

      // Buscar parámetros que puedan referenciar prompts
      const promptParams = tool.parameters.filter(p => 
        p.name.includes('prompt') ||
        p.description?.includes('prompt')
      );
      
      if (promptParams.length > 0) {
        toolsUsingPrompts.push({
          toolName: tool.name,
          promptNames: prompts.map(p => p.name)
        });
      }
    });

    return { toolsUsingResources, toolsUsingPrompts };
  }

  private toCustomFormat(schema: CompleteServerSchema, customSchema: any) {
    // Aplicar transformación según esquema propietario del usuario
    if (!customSchema) return schema;
    
    // Implementar transformación basada en customSchema
    return schema;
  }

  private toOpenAPIFormat(schema: CompleteServerSchema) {
    // Convertir a formato OpenAPI 3.0
    return {
      openapi: "3.0.0",
      info: {
        title: "MCP Server API",
        version: "1.0.0"
      },
      paths: this.convertToolsToOpenAPIPaths(schema.tools),
      components: {
        schemas: this.generateOpenAPISchemas(schema)
      }
    };
  }

  private toJSONSchemaFormat(schema: CompleteServerSchema) {
    // Convertir a JSON Schema format
    return {
      $schema: "http://json-schema.org/draft-07/schema#",
      title: "MCP Server Schema",
      type: "object",
      properties: {
        tools: {
          type: "array",
          items: { $ref: "#/definitions/Tool" }
        },
        resources: {
          type: "array", 
          items: { $ref: "#/definitions/Resource" }
        },
        prompts: {
          type: "array",
          items: { $ref: "#/definitions/Prompt" }
        }
      },
      definitions: this.generateJSONSchemaDefinitions(schema)
    };
  }

  private convertToolsToOpenAPIPaths(tools: ParsedTool[]) {
    // Implementar conversión de tools a paths de OpenAPI
    return {};
  }

  private generateOpenAPISchemas(schema: CompleteServerSchema) {
    // Generar esquemas OpenAPI
    return {};
  }

  private generateJSONSchemaDefinitions(schema: CompleteServerSchema) {
    // Generar definiciones JSON Schema
    return {};
  }
}
```

### 6. CLI Principal (`index.ts`)
```typescript
import { Command } from 'commander';
import { MCPToolsExtractor } from './mcpClient.js';
import { SchemaParser } from './schemaParser.js';
import { ToolsTransformer } from './transformer.js';

const program = new Command();

program
  .name('mcp-tools-parser')
  .description('Extract and transform MCP server tools, resources and prompts with schemas')
  .version('1.0.0');

program
  .command('extract')
  .description('Extract complete metadata from MCP server')
  .requiredOption('-s, --server <url>', 'MCP server URL or command')
  .option('-t, --transport <type>', 'Transport type', 'sse')
  .option('-o, --output <file>', 'Output file')
  .option('-f, --format <format>', 'Output format', 'custom')
  .option('--tools-only', 'Extract only tools')
  .option('--resources-only', 'Extract only resources')  
  .option('--prompts-only', 'Extract only prompts')
  .option('--include-relationships', 'Analyze relationships between components')
  .action(async (options) => {
    const extractor = new MCPToolsExtractor();
    await extractor.connectToServer(options.server, options.transport);
    
    let metadata;
    if (options.toolsOnly) {
      const tools = await extractor.extractTools();
      metadata = { tools, resources: [], resourceTemplates: [], prompts: [] };
    } else if (options.resourcesOnly) {
      const resources = await extractor.extractResources();
      const resourceTemplates = await extractor.extractResourceTemplates();
      metadata = { tools: [], resources, resourceTemplates, prompts: [] };
    } else if (options.promptsOnly) {
      const prompts = await extractor.extractPrompts();
      metadata = { tools: [], resources: [], resourceTemplates: [], prompts };
    } else {
      metadata = await extractor.extractCompleteMetadata();
    }
    
    const transformer = new ToolsTransformer();
    const result = transformer.transform(metadata, {
      outputFormat: options.format,
      includeMetadata: true,
      groupByCategory: true,
      includeResources: !options.toolsOnly,
      includePrompts: !options.toolsOnly
    });
    
    if (options.output) {
      await fs.writeFile(options.output, JSON.stringify(result, null, 2));
      console.log(`Schema exported to ${options.output}`);
    } else {
      console.log(JSON.stringify(result, null, 2));
    }
  });

program
  .command('resource')
  .description('Read specific resource content')
  .requiredOption('-s, --server <url>', 'MCP server URL or command')
  .requiredOption('-u, --uri <uri>', 'Resource URI')
  .option('-t, --transport <type>', 'Transport type', 'sse')
  .action(async (options) => {
    const extractor = new MCPToolsExtractor();
    await extractor.connectToServer(options.server, options.transport);
    
    const content = await extractor.readSpecificResource(options.uri);
    console.log(JSON.stringify(content, null, 2));
  });

program
  .command('prompt')
  .description('Get specific prompt with arguments')
  .requiredOption('-s, --server <url>', 'MCP server URL or command')
  .requiredOption('-n, --name <name>', 'Prompt name')
  .option('-t, --transport <type>', 'Transport type', 'sse')
  .option('-a, --args <args>', 'Prompt arguments as JSON string')
  .action(async (options) => {
    const extractor = new MCPToolsExtractor();
    await extractor.connectToServer(options.server, options.transport);
    
    const args = options.args ? JSON.parse(options.args) : {};
    const content = await extractor.getSpecificPrompt(options.name, args);
    console.log(JSON.stringify(content, null, 2));
  });
```

## Casos de Uso

### 1. Extracción Completa del Servidor
```bash
npm run parse -- extract --server http://localhost:3003 --transport streamable-http
```

### 2. Solo Tools con Esquemas
```bash
npm run parse -- extract --server http://localhost:3003 --tools-only --output tools-schema.json
```

### 3. Solo Resources y Templates
```bash
npm run parse -- extract --server http://localhost:3003 --resources-only --output resources.json
```

### 4. Solo Prompts con Argumentos
```bash
npm run parse -- extract --server http://localhost:3003 --prompts-only --output prompts.json
```

### 5. Leer Resource Específico
```bash
npm run parse -- resource --server http://localhost:3003 --uri "devops://project/status"
```

### 6. Obtener Prompt con Argumentos
```bash
npm run parse -- prompt --server http://localhost:3003 --name "start-system" --args '{"environment":"production"}'
```

### 7. Transformación a Esquema Personalizado
```bash
npm run parse -- extract --server http://localhost:3003 --format custom --include-relationships --output complete-schema.json
```

### 8. Integración Programática
```typescript
const extractor = new MCPToolsExtractor();
await extractor.connectToServer('http://localhost:3003', 'streamable-http');

// Metadata completa
const metadata = await extractor.extractToolsWithMetadata();

// Leer resource específico
const projectStatus = await extractor.readSpecificResource('devops://project/status');

// Obtener prompt específico
const systemPrompt = await extractor.getSpecificPrompt('start-system', { environment: 'dev' });
```

## Puntos Críticos de Implementación

1. **Copiar exactamente la lógica de transporte** del inspector oficial
2. **Usar el mismo Client del SDK** para garantizar compatibilidad
3. **Preservar los esquemas JSON Schema completos** de inputSchema
4. **Manejar errores de conexión** como lo hace el inspector
5. **Soportar todos los tipos de transporte** (stdio, sse, streamable-http)

## Resultado Esperado

El parseador debe poder extraer de cualquier servidor MCP:
- **Tools**: Lista completa con nombres, descripciones y esquemas JSON Schema de parámetros
- **Resources**: URIs, nombres, tipos MIME y contenido de recursos estáticos
- **Resource Templates**: Plantillas dinámicas con argumentos para URIs variables
- **Prompts**: Nombres, descripciones y esquemas de argumentos requeridos
- **Relationships**: Análisis de qué tools pueden usar qué resources/prompts
- **Transformación**: Conversión a formato personalizado del usuario
- **Metadata Completa**: Información del servidor y estadísticas

### Ejemplo de Output Completo:
```json
{
  "serverInfo": {
    "name": "devops-mcp-server",
    "extractedAt": "2025-09-19T18:30:00.000Z",
    "toolsCount": 20,
    "resourcesCount": 2,
    "promptsCount": 2
  },
  "tools": [
    {
      "name": "add_prompt",
      "description": "Añadir un nuevo prompt al servidor",
      "parameters": [
        {
          "name": "id",
          "type": "string",
          "description": "ID único del prompt",
          "required": true,
          "schema": { "type": "string" }
        }
      ],
      "category": "crud-operations"
    }
  ],
  "resources": [
    {
      "uri": "devops://project/status",
      "name": "Estado del Proyecto",
      "description": "Estado actual del proyecto y servicios",
      "mimeType": "application/json",
      "category": "status"
    }
  ],
  "prompts": [
    {
      "name": "start-system",
      "description": "Prompt para arrancar el sistema usando npm start",
      "arguments": [
        {
          "name": "environment",
          "description": "Entorno de ejecución",
          "required": false
        }
      ],
      "category": "devops"
    }
  ],
  "relationships": {
    "toolsUsingResources": [
      {
        "toolName": "get_server_status",
        "resourceUris": ["devops://project/status"]
      }
    ],
    "toolsUsingPrompts": []
  }
}
```

Esta implementación replicará exactamente la funcionalidad del inspector oficial pero enfocada específicamente en la extracción y transformación completa de esquemas de tools, resources y prompts.